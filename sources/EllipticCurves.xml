<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EllipticCurves</name>
    </assembly>
    <members>
        <member name="T:EllipticCurves.BigRational">
            <summary>
            A minimal, allocation-friendly rational type for exact arithmetic over Q.
            
            Invariants:
             ‚Ä¢ Always stored in canonical form: gcd(|Num|, Den) = 1
             ‚Ä¢ Denominator is strictly positive (Den > 0)
             ‚Ä¢ Zero is represented as 0/1
            
            Notes:
             ‚Ä¢ This is an immutable value type with value semantics (Equals/GetHashCode implemented).
             ‚Ä¢ Designed for exact math in number theory (elliptic curves, invariants, etc.),
               not for floating-point approximations.
            </summary>
        </member>
        <member name="P:EllipticCurves.BigRational.Num">
            <summary>Numerator (can be negative).</summary>
        </member>
        <member name="P:EllipticCurves.BigRational.Den">
            <summary>Denominator (strictly positive by invariant).</summary>
        </member>
        <member name="F:EllipticCurves.BigRational.Zero">
            <summary>The rational number 0 (stored as 0/1).</summary>
        </member>
        <member name="F:EllipticCurves.BigRational.One">
            <summary>The rational number 1 (stored as 1/1).</summary>
        </member>
        <member name="F:EllipticCurves.BigRational.Two">
            <summary>The rational number 2 (stored as 2/1).</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.#ctor(System.Int64)">
            <summary>Create from a 64-bit integer (n/1).</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.#ctor(System.Numerics.BigInteger)">
            <summary>Create from a BigInteger (n/1).</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.#ctor(System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>
            Create from a numerator/denominator pair and normalize:
             ‚Ä¢ throw if den == 0
             ‚Ä¢ move the sign into the numerator
             ‚Ä¢ divide by gcd(|num|, den)
             ‚Ä¢ normalize zero to 0/1
            </summary>
        </member>
        <member name="M:EllipticCurves.BigRational.FromInt(System.Int64)">
            <summary>Create from an integer (n/1).</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.FromFraction(System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>Create from an unreduced fraction (num/den); will be normalized.</summary>
        </member>
        <member name="P:EllipticCurves.BigRational.IsZero">
            <summary>True if this is exactly zero.</summary>
        </member>
        <member name="P:EllipticCurves.BigRational.Sign">
            <summary>Sign of the rational: ‚àí1, 0, or +1.</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.Abs">
            <summary>Absolute value (|Num|/Den).</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.Negate">
            <summary>Negation (‚àíNum/Den).</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.Reciprocal">
            <summary>Multiplicative inverse (Den/Num). Throws if zero.</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_Addition(EllipticCurves.BigRational,EllipticCurves.BigRational)">
            <summary>Exact addition with normalization.</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_Subtraction(EllipticCurves.BigRational,EllipticCurves.BigRational)">
            <summary>Exact subtraction with normalization.</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_Multiply(EllipticCurves.BigRational,EllipticCurves.BigRational)">
            <summary>Exact multiplication with normalization.</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_Division(EllipticCurves.BigRational,EllipticCurves.BigRational)">
            <summary>Exact division with normalization. Throws if divisor is zero.</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_UnaryNegation(EllipticCurves.BigRational)">
            <summary>Unary negation.</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.Pow(EllipticCurves.BigRational,System.Int32)">
            <summary>
            r^k for integer k ‚â• 0. For k == 0 returns 1 by convention.
            Note: if you need negative powers, use Reciprocal with a positive exponent.
            </summary>
        </member>
        <member name="M:EllipticCurves.BigRational.IsSquare(EllipticCurves.BigRational,EllipticCurves.BigRational@)">
            <summary>
            Exact test for a rational square: returns true iff r = s^2 for some s ‚àà Q
            and outputs s in canonical form. Works by requiring both numerator and
            denominator to be perfect squares in Z.
            </summary>
        </member>
        <member name="M:EllipticCurves.BigRational.TryIntegerSquareRoot(System.Numerics.BigInteger,System.Numerics.BigInteger@)">
            <summary>
            Try exact integer square root: returns true iff n is a perfect square and
            outputs rt = sqrt(n). Otherwise returns false and sets rt = floor(sqrt(n)).
            </summary>
        </member>
        <member name="M:EllipticCurves.BigRational.IntegerSquareRoot(System.Numerics.BigInteger)">
            <summary>
            floor(sqrt(n)) for n ‚â• 0 using a monotone Newton iteration.
            For n ‚àà {0,1} returns n; otherwise converges from above.
            </summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_Equality(EllipticCurves.BigRational,EllipticCurves.BigRational)">
            <summary>Value equality (uses canonical representation, so structural equality works).</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_Inequality(EllipticCurves.BigRational,EllipticCurves.BigRational)">
            <summary>Value inequality.</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_LessThan(EllipticCurves.BigRational,EllipticCurves.BigRational)">
            <summary>Strict less-than (exact ‚Ñö order via cross-products).</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_GreaterThan(EllipticCurves.BigRational,EllipticCurves.BigRational)">
            <summary>Strict greater-than (exact order on ‚Ñö; cross-products).</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_LessThanOrEqual(EllipticCurves.BigRational,EllipticCurves.BigRational)">
            <summary>Less-than or equal (exact order on ‚Ñö; cross-products).</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_GreaterThanOrEqual(EllipticCurves.BigRational,EllipticCurves.BigRational)">
            <summary>Greater-than or equal (exact order on ‚Ñö; cross-products).</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_Implicit(System.Int64)~EllipticCurves.BigRational">
            <summary>Defines an implicit conversion of a number to BigRational.</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_Implicit(System.UInt64)~EllipticCurves.BigRational">
            <summary>Defines an implicit conversion of a number to BigRational.</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_Implicit(System.Int16)~EllipticCurves.BigRational">
            <summary>Defines an implicit conversion of a number to BigRational.</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_Implicit(System.UInt16)~EllipticCurves.BigRational">
            <summary>Defines an implicit conversion of a number to BigRational.</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_Implicit(System.Int32)~EllipticCurves.BigRational">
            <summary>Defines an implicit conversion of a number to BigRational.</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_Implicit(System.UInt32)~EllipticCurves.BigRational">
            <summary>Defines an implicit conversion of a number to BigRational.</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_Implicit(System.Byte)~EllipticCurves.BigRational">
            <summary>Defines an implicit conversion of a number to BigRational.</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.op_Implicit(System.SByte)~EllipticCurves.BigRational">
            <summary>Defines an implicit conversion of a number to BigRational.</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.CompareTo(EllipticCurves.BigRational)">
            <summary>
            Lexicographic-free comparison via cross-multiplication:
            compare Num/Den and other.Num/other.Den exactly.
            </summary>
        </member>
        <member name="M:EllipticCurves.BigRational.Equals(EllipticCurves.BigRational)">
            <summary>Typed equality (same as operator ==).</summary>
        </member>
        <member name="M:EllipticCurves.BigRational.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:EllipticCurves.BigRational.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:EllipticCurves.BigRational.ToString">
            <summary>
            Culture-invariant string: "n" for integers, "n/d" for proper fractions.
            Intended for logs/debugging and round-trippable parsing in simple cases.
            </summary>
        </member>
        <member name="T:EllipticCurves.EllipticCurveLMFDB">
            <summary>
            Thin helper that fetches basic invariants for an elliptic curve over ‚Ñö from the LMFDB API,
            matching by the exact rational j-invariant and verifying Q‚Äìisomorphism via (c4,c6,Œî).
            
            Design:
             ‚Ä¢ Single network call to <c>/api/ec_curvedata</c> (no secondary requests).
             ‚Ä¢ Minimal local cache of the selected record (a-invariants, conductor, rank, etc.).
             ‚Ä¢ No retries/backoff: the caller controls lifetime by constructing a new instance.
            
            Safety:
             ‚Ä¢ Throws <see cref="T:System.InvalidOperationException"/> when the record is not initialized
               or if no Q‚Äìisomorphic curve is found for the given j-invariant.
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveLMFDB.#ctor(EllipticCurves.EllipticCurveQ)">
            <summary>
            Construct and immediately fetch/cached the matching LMFDB record
            for <paramref name="ellipticCurve"/> (matching by j‚Äìinvariant and Q‚Äìisomorphism).
            </summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveLMFDB.Rank">
            <summary>
            Algebraic rank (Mordell‚ÄìWeil rank) from LMFDB curvedata.
            </summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveLMFDB.AnalyticRank">
            <summary>
            Analytic rank (ord_{s=1} L(E,s)) when present in LMFDB; otherwise <c>null</c>.
            </summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveLMFDB.Conductor">
            <summary>
            Conductor N of the (minimal) elliptic curve over ‚Ñö.
            </summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveLMFDB.Label">
            <summary>
            LMFDB label (e.g. <c>"48.a3"</c>) of the matched minimal model.
            </summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveLMFDB.Url">
            <summary>
            Canonical human-facing LMFDB URL of the curve's page (or null if label is missing).
            </summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveLMFDB.TorsionStructure">
            <summary>
            Torsion structure in a compact textual form, e.g. <c>"Z/2Z"</c> or <c>"Z/2Z x Z/4Z"</c>.
            </summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveLMFDB.GlobalMinimalModel">
            <summary>
            Minimal (global) integral Weierstrass model reconstructed from the a-invariants in LMFDB.
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveLMFDB.GetLmfdbRecord(EllipticCurves.EllipticCurveQ)">
            <summary>
            Fetch a list of candidates by exact rational j-invariant, then select the unique
            curve Q‚Äìisomorphic to <paramref name="ellipticCurve"/> by verifying (c4,c6,Œî) scaling.
            Caches the selected record; subsequent property reads are served from the cache.
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveLMFDB.FormatTorsionStructure(System.Text.Json.JsonElement)">
            <summary>
            Accepts either an integer array (e.g. [2,4]) or a ready string (e.g. "Z/2Z x Z/4Z")
            and returns a normalized textual form "Z/nZ" or "Z/aZ x Z/bZ".
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveLMFDB.ParseAinvs(System.Text.Json.JsonElement)">
            <summary>
            Parse a-invariants from LMFDB payload. Supports either a JSON array of numbers
            or a string form "[a1,a2,a3,a4,a6]".
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveLMFDB.ReadBigInteger(System.Text.Json.JsonElement)">
            <summary>
            Parse a BigInteger from either a numeric JSON token or a string token.
            </summary>
        </member>
        <member name="T:EllipticCurves.EllipticCurvePoint">
            <summary>
            Immutable affine point on an elliptic curve over <c>‚Ñö</c> (the rationals).
            
            <para>
            Representation:
            <list type="bullet">
              <item><description>Finite points are stored as exact rationals <see cref="F:EllipticCurves.EllipticCurvePoint.X"/>, <see cref="F:EllipticCurves.EllipticCurvePoint.Y"/> with <see cref="F:EllipticCurves.EllipticCurvePoint.IsInfinity"/> = <c>false</c>.</description></item>
              <item><description>The neutral element (point at infinity) is represented canonically by <see cref="P:EllipticCurves.EllipticCurvePoint.Infinity"/> with <see cref="F:EllipticCurves.EllipticCurvePoint.IsInfinity"/> = <c>true</c> and <see cref="F:EllipticCurves.EllipticCurvePoint.X"/>=<see cref="F:EllipticCurves.EllipticCurvePoint.Y"/>=<c>0</c>.</description></item>
            </list>
            </para>
            
            <para>
            Equality and hashing follow value semantics:
            two finite points are equal iff both coordinates are equal as rationals; the
            infinity point is only equal to itself.
            </para>
            </summary>
        </member>
        <member name="F:EllipticCurves.EllipticCurvePoint.X">
            <summary>
            Affine <c>x</c>-coordinate (exact rational). For <see cref="P:EllipticCurves.EllipticCurvePoint.Infinity"/>, this is <c>0</c>.
            </summary>
        </member>
        <member name="F:EllipticCurves.EllipticCurvePoint.Y">
            <summary>
            Affine <c>y</c>-coordinate (exact rational). For <see cref="P:EllipticCurves.EllipticCurvePoint.Infinity"/>, this is <c>0</c>.
            </summary>
        </member>
        <member name="F:EllipticCurves.EllipticCurvePoint.IsInfinity">
            <summary>
            Indicates whether the point is the neutral element (the point at infinity).
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurvePoint.#ctor(EllipticCurves.BigRational,EllipticCurves.BigRational)">
            <summary>
            Create a finite point with given affine coordinates <paramref name="x"/>, <paramref name="y"/>.
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurvePoint.#ctor(System.Boolean)">
            <summary>
            Private constructor used to create the canonical infinity element.
            </summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurvePoint.Infinity">
            <summary>
            The neutral element of the elliptic curve group (point at infinity).
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurvePoint.Equals(EllipticCurves.EllipticCurvePoint)">
            <summary>
            Value equality: finite points compare by coordinates; infinity compares only to infinity.
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurvePoint.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:EllipticCurves.EllipticCurvePoint.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:EllipticCurves.EllipticCurvePoint.ToString">
            <summary>
            Human-readable representation: <c>"O"</c> for infinity; <c>"(x, y)"</c> for finite points.
            Uses <see cref="M:EllipticCurves.BigRational.ToString"/> for coordinates (culture-invariant).
            </summary>
        </member>
        <member name="T:EllipticCurves.EllipticCurveQ">
            <summary>
            Elliptic curve over ‚Ñö in the general Weierstrass form
                y^2 + a1*x*y + a3*y = x^3 + a2*x^2 + a4*x + a6 .
            All coefficients are exact rationals (BigRational). This type implements:
             ‚Ä¢ exact invariants (b2,b4,b6,b8), c4, c6, Œî, j,
             ‚Ä¢ the general Weierstrass group law (Add/Double/Multiply),
             ‚Ä¢ conversion to the short model y^2 = x^3 + A x + B in characteristic 0,
             ‚Ä¢ bounded search for rational/integral points,
             ‚Ä¢ a self-contained computation of torsion points over ‚Ñö
               (via Lutz‚ÄìNagell + reductions), including mapping back to the original model.
            </summary>
            <remarks>Create an elliptic curve y^2 + a1*x*y + a3*y = x^3 + a2*x^2 + a4*x + a6.</remarks>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.#ctor(EllipticCurves.BigRational,EllipticCurves.BigRational,EllipticCurves.BigRational,EllipticCurves.BigRational,EllipticCurves.BigRational)">
            <summary>
            Elliptic curve over ‚Ñö in the general Weierstrass form
                y^2 + a1*x*y + a3*y = x^3 + a2*x^2 + a4*x + a6 .
            All coefficients are exact rationals (BigRational). This type implements:
             ‚Ä¢ exact invariants (b2,b4,b6,b8), c4, c6, Œî, j,
             ‚Ä¢ the general Weierstrass group law (Add/Double/Multiply),
             ‚Ä¢ conversion to the short model y^2 = x^3 + A x + B in characteristic 0,
             ‚Ä¢ bounded search for rational/integral points,
             ‚Ä¢ a self-contained computation of torsion points over ‚Ñö
               (via Lutz‚ÄìNagell + reductions), including mapping back to the original model.
            </summary>
            <remarks>Create an elliptic curve y^2 + a1*x*y + a3*y = x^3 + a2*x^2 + a4*x + a6.</remarks>
        </member>
        <member name="P:EllipticCurves.EllipticCurveQ.A1">
            <summary>a1 coefficient in the general Weierstrass equation.</summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveQ.A2">
            <summary>a2 coefficient in the general Weierstrass equation.</summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveQ.A3">
            <summary>a3 coefficient in the general Weierstrass equation.</summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveQ.A4">
            <summary>a4 coefficient in the general Weierstrass equation.</summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveQ.A6">
            <summary>a6 coefficient in the general Weierstrass equation.</summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveQ.B2">
            <summary>b2 = a1^2 + 4 a2.</summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveQ.B4">
            <summary>b4 = 2 a4 + a1 a3.</summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveQ.B6">
            <summary>b6 = a3^2 + 4 a6.</summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveQ.B8">
            <summary>b8 = a1^2 a6 + 4 a2 a6 ‚àí a1 a3 a4 + a2 a3^2 ‚àí a4^2.</summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveQ.C4">
            <summary>c4 = b2^2 ‚àí 24 b4.</summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveQ.C6">
            <summary>c6 = ‚àíb2^3 + 36 b2 b4 ‚àí 216 b6.</summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveQ.Discriminant">
            <summary>
            Discriminant Œî = ‚àíb2^2 b8 ‚àí 8 b4^3 ‚àí 27 b6^2 + 9 b2 b4 b6.
            The curve is nonsingular iff Œî ‚â† 0.
            </summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveQ.JInvariant">
            <summary>j-invariant j = c4^3 / Œî (only defined if Œî ‚â† 0).</summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveQ.IsSingular">
            <summary>True iff the curve is singular (Œî = 0).</summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.IsOnCurve(EllipticCurves.EllipticCurvePoint)">
            <summary>Exact membership test for a point in affine coordinates.</summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.Negate(EllipticCurves.EllipticCurvePoint)">
            <summary>Group inverse: ‚àí(x,y) = (x, ‚àíy ‚àí a1 x ‚àí a3).</summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.Add(EllipticCurves.EllipticCurvePoint,EllipticCurves.EllipticCurvePoint)">
            <summary>
            Group law (general Weierstrass). Handles P, Q, doubling, and the vertical-tangent case.
            Slope:
             ‚Ä¢ If x1 ‚â† x2: Œª = (y2 ‚àí y1)/(x2 ‚àí x1).
             ‚Ä¢ If P = Q:   Œª = (3x1^2 + 2a2 x1 + a4 ‚àí a1 y1) / (2y1 + a1 x1 + a3).
            Then:
             x3 = Œª^2 + a1 Œª ‚àí a2 ‚àí x1 ‚àí x2,
             ŒΩ = y1 ‚àí Œª x1,
             y3 = ‚àí(Œª + a1) x3 ‚àí a3 ‚àí ŒΩ.
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.Double(EllipticCurves.EllipticCurvePoint)">
            <summary>Point doubling: 2P = P + P.</summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.Subtract(EllipticCurves.EllipticCurvePoint,EllipticCurves.EllipticCurvePoint)">
            <summary>Point subtraction: P ‚àí Q = P + (‚àíQ).</summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.Multiply(EllipticCurves.EllipticCurvePoint,System.Numerics.BigInteger)">
            <summary>
            Scalar multiplication nP using left-to-right double-and-add.
            Supports n &lt; 0 (via negation) and n = 0 (returns O).
            </summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveQ.ShortWeierstrass">
            <summary>
            Convert to the short Weierstrass model in characteristic 0.
            Steps:
             1) Complete the square: y = y' ‚àí (a1 x + a3)/2 ‚áí y'^2 = x^3 + a2' x^2 + a4' x + a6'
             2) Remove x^2-term:    x = X ‚àí a2'/3          ‚áí y'^2 = X^3 + A X + B
            Returns a curve with (a1,a2,a3) = (0,0,0) and (a4,a6) = (A,B).
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.RationalPoints(System.Int32,System.Int32)">
            <summary>
            Enumerate rational points with bounded x = m/n (|m| ‚â§ numMax, 1 ‚â§ n ‚â§ denMax, gcd(m,n)=1).
            Uses the substitution y' = y + (a1 x + a3)/2 to test y'^2 being a rational square.
            Returns O first, then affine points found in the box.
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.IntegralPoints(System.Int32)">
            <summary>
            Enumerate integral points with |x| ‚â§ xmax (a thin wrapper over RationalPoints with denMax=1).
            Returns O first, then affine integral points.
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.QuadraticTwist(System.Numerics.BigInteger)">
            <summary>
            Returns the quadratic twist of this curve by a non-zero integer <paramref name="d"/>.
            The twisted curve E_d is isomorphic to E over the quadratic extension ‚Ñö(‚àöd),
            but generally not over ‚Ñö (unless d is a square).
            </summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveQ.TorsionPoints">
            <summary>
            Compute (and cache) the full set of rational torsion points of E(‚Ñö).
            Pipeline (no LMFDB):
             0) Convert to short integral model Y^2 = X^3 + A'X + B'.
             1) Use reductions at several good primes to restrict possible orders (Mazur admissible).
             2) Apply Lutz‚ÄìNagell: Y^2 | |Œî'| and search via divisors to find integral torsion points.
             3) Map the points back to the ORIGINAL model (inverse of the short/scale transform).
            Set contains Infinity and all affine torsion points; subsequent calls reuse the cache.
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.IsTorsionPoint(EllipticCurves.EllipticCurvePoint)">
            <summary>
            True iff the given point lies on the curve and is torsion (order &lt; ‚àû).
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.TorsionOrder(EllipticCurves.EllipticCurvePoint)">
            <summary>
            Return the exact order of a torsion point or <c>null</c> if it has infinite order.
            The point must lie on the curve; Infinity is treated as order 1.
            </summary>
        </member>
        <member name="P:EllipticCurves.EllipticCurveQ.TorsionStructure">
            <summary>
            Group structure of the rational torsion subgroup E(‚Ñö)_tors inferred from TorsionPoints.
            Returns a label like "Z/1Z", "Z/4Z", or "Z/2Z x Z/4Z".
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.IsIsomorphic(EllipticCurves.EllipticCurveQ)">
            <summary>
            Return true iff this curve is Q‚Äìisomorphic to <paramref name="other"/>.
            Uses invariant scaling test (c4,c6,Œî) and outputs the scaling factor u (if requested).
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.IsIsomorphic(EllipticCurves.EllipticCurveQ,EllipticCurves.BigRational@)">
            <summary>
            Return true iff this curve is Q‚Äìisomorphic to <paramref name="other"/>; also returns u s.t.
            c4_this = u^4 c4_other, c6_this = u^6 c6_other, Œî_this = u^12 Œî_other.
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.FromJInvariant(EllipticCurves.BigRational)">
            <summary>
            Constructs an elliptic curve over ‚Ñö with the specified j-invariant.
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.ToString">
            <summary>Pretty printer that omits zero terms and formats signs compactly.</summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.AppendTerm(System.Text.StringBuilder,EllipticCurves.BigRational,System.String)">
            <summary>Helper for ToString(): appends ¬± coeff*monomial, skipping zeros and eliding coeff=1 where appropriate.</summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.Equals(EllipticCurves.EllipticCurveQ)">
            <summary>
            Value equality: finite points compare by coordinates; infinity compares only to infinity.
            </summary>
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EllipticCurves.EllipticCurveQ.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:EllipticCurves.InternalMath">
            <summary>
            Internal numeric helpers used across the library.
            
            Scope:
            ‚Ä¢ Invariant computations for integral Weierstrass models (c4, c6, Œî).
            ‚Ä¢ Q‚Äìisomorphism checks via scaling of invariants (u^4, u^6, u^12).
            ‚Ä¢ Exact k-th roots over ‚Ñö and ‚Ñ§ (Newton / integer root tests).
            ‚Ä¢ Fast torsion tests (order divisibility and small Mazur fallback).
            ‚Ä¢ Small finite-field helpers: Legendre symbol, modular exponentiation,
              and counting points on short Weierstrass curves over ùîΩ_p.
            ‚Ä¢ Basic integer factorization (Pollard‚ÄìRho + Miller‚ÄìRabin) to build
              square divisors of |Œî| and enumerations of divisors.
            
            Notes:
            ‚Ä¢ All methods are deterministic and allocation-light.
            ‚Ä¢ Big-integer operations can be expensive for huge inputs‚Äîthese are
              intended for typical arithmetic of elliptic curves over ‚Ñö.
            ‚Ä¢ If you target an older C# language version, replace collection
              expressions like `int[] small = [2,3,...]` with classic initializers
              `new int[] { 2, 3, ... }`.
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.InvariantsIntFromAinvs(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>
            Compute integral invariants (c4, c6, Œî) from integral a-invariants [a1,a2,a3,a4,a6].
            Assumes all inputs are integers (integral model). No normalization/scaling is applied here.
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.IntegralInvariants(EllipticCurves.EllipticCurveQ)">
            <summary>
            Build an integral Weierstrass model of curve C by the scaling (x,y) = (L^2 X, L^3 Y),
            where L = lcm(denominators of a_i). Returns the integer invariants (c4,c6,Œî).
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.IsQIsomorphic(EllipticCurves.BigRational,EllipticCurves.BigRational,EllipticCurves.BigRational,System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger,EllipticCurves.BigRational@)">
            <summary>
            Check whether two elliptic curves are Q‚Äìisomorphic by testing the scaling
            relations on invariants: c4_E = u^4 c4_C, c6_E = u^6 c6_C, Œî_E = u^12 Œî_C for some u ‚àà ‚Ñö.
            Outputs the scaling factor u if successful.
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.TryRationalKthRoot(EllipticCurves.BigRational,System.Int32,EllipticCurves.BigRational@)">
            <summary>
            Try to compute a rational k-th root of r ‚àà ‚Ñö (k ‚â• 2). Returns true iff
            r = root^k for some rational root in canonical form.
            Implementation: require both |Num| and Den to be perfect k-th powers in ‚Ñ§.
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.TryIntegerKthRoot(System.Numerics.BigInteger,System.Int32,System.Numerics.BigInteger@)">
            <summary>
            Try to compute exact integer k-th root: return true iff n = rt^k for some integer rt (rt ‚â• 0).
            Otherwise, returns false and rt = floor(n^(1/k)).
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.IntegerKthRoot(System.Numerics.BigInteger,System.Int32)">
            <summary>
            floor(n^(1/k)) for n ‚â• 0 using Newton's method generalized to k-th roots.
            For small n it exits fast; for large n it converges monotonically.
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.IsTorsionWithCandidates(EllipticCurves.EllipticCurveQ,EllipticCurves.EllipticCurvePoint,System.Collections.Generic.List{System.Int32})">
            <summary>
            Check whether a point is torsion by first testing divisibility by candidate orders
            (coming from gcd of #E(ùîΩ_p) over a few good primes), and if none matches,
            falling back to a bounded exact check up to 12 (Mazur‚Äôs bound).
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.OrderDivides(EllipticCurves.EllipticCurveQ,EllipticCurves.EllipticCurvePoint,System.Int32)">
            <summary>
            Return true iff n*P = O (the point at infinity), i.e. the order of P divides n.
            Computed with double-and-add (no precomputation).
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.Lcm(System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>
            Least common multiple for nonzero BigIntegers. If either argument is 0,
            this returns 0 by the standard convention.
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.EvalCubic(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>
            Evaluate the cubic X^3 + A X + B at integer X.
            Used for 2-torsion and Lutz‚ÄìNagell searches on short integral models.
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.IntegerSqrt(System.Numerics.BigInteger)">
            <summary>
            floor(sqrt(n)) for n ‚â• 0 via a monotone Newton iteration specialized to k=2.
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.CountPointsFpShort(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Int32)">
            <summary>
            Count points on a short Weierstrass curve Y^2 = X^3 + A X + B over ùîΩ_p (p odd and small).
            Uses Legendre symbol to count square/non-square values of RHS for each X.
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.Legendre(System.Int32,System.Int32)">
            <summary>
            Legendre symbol (a|p) for odd prime p: returns 0 if a ‚â° 0 (mod p), 1 if a is a QR, ‚àí1 otherwise.
            Euler‚Äôs criterion: a^((p‚àí1)/2) ‚â° (a|p) (mod p).
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.ModPow(System.Int32,System.Int32,System.Int32)">
            <summary>
            Fast modular exponentiation (a^e mod m) with 32-bit ints.
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.FactorAbs(System.Numerics.BigInteger)">
            <summary>
            Trial factorization via Pollard‚ÄìRho with Miller‚ÄìRabin primality tests.
            Returns a dictionary of prime factors with exponents for |n|.
            Note: For very large inputs, this is a heuristic/‚Äúgood enough‚Äù routine.
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.FactorRec(System.Numerics.BigInteger,System.Collections.Generic.Dictionary{System.Numerics.BigInteger,System.Int32})">
            <summary>
            Recursive helper for FactorAbs: splits composite n into prime factors using
            Miller‚ÄìRabin (probable prime) and Pollard‚ÄìRho to find nontrivial divisors.
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.IsProbablePrime(System.Numerics.BigInteger)">
            <summary>
            Probable-prime test: quick small trial division, then Miller‚ÄìRabin with a fixed base set.
            For 64-bit sized integers the chosen bases are deterministic; for larger they are practical.
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.MillerRabinCheck(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Int32,System.Int32)">
            <summary>
            One Miller‚ÄìRabin round for given odd n, with factorization n‚àí1 = d¬∑2^s and base a.
            Returns false if n is definitely composite, true if it passes this round.
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.PollardRho(System.Numerics.BigInteger)">
            <summary>
            Pollard‚ÄìRho with a simple f(x)=x^2+c map and Brent-like cycle detection.
            Returns a nontrivial divisor of odd composite n (heuristic, but very effective in practice).
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.RandomBelow(System.Numerics.BigInteger,System.Random)">
            <summary>
            Return a random integer r with 0 &lt; r &lt; n using the provided PRNG.
            The distribution is not cryptographically secure (intended for math utilities).
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.EnumerateSquareDivisors(System.Collections.Generic.Dictionary{System.Numerics.BigInteger,System.Int32})">
            <summary>
            Enumerate all square divisors y2 of |Œî| using its prime factorization:
            if |Œî|=‚àè p_i^{e_i}, then y2 ranges over ‚àè p_i^{2f_i} with 0‚â§f_i‚â§‚åäe_i/2‚åã.
            </summary>
        </member>
        <member name="M:EllipticCurves.InternalMath.EnumerateDivisorsAbs(System.Numerics.BigInteger)">
            <summary>
            Enumerate all positive divisors of |n| from its factorization (includes 1 and |n|).
            Returns 0 only if input n was 0 (by convention).
            </summary>
        </member>
    </members>
</doc>
